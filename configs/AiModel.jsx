const {
    GoogleGenerativeAI,
    HarmCategory,
    HarmBlockThreshold,
  } = require("@google/generative-ai");
//   const fs = require("node:fs");
//   const mime = require("mime-types");
  
const apiKey = "AIzaSyDi47uMumsn-8t4dWVsU4dV5YpehU2MvMI";  // Replace with your Gemini API key
const genAI = new GoogleGenerativeAI(apiKey);

  
  const model = genAI.getGenerativeModel({
    model: "gemini-2.0-flash",
  });
  
  const generationConfig = {
    temperature: 1,
    topP: 0.95,
    topK: 40,
    maxOutputTokens: 8192,
    responseModalities: [
    ],
    responseMimeType: "application/json",
  };
  

  export  const GenerateCourseLayout_Ai = model.startChat({
      generationConfig,
      history: [
        {
          role: "user",
          parts: [
            {text: "generate A Course Tutorial on Following Detail with field as Course which has Name, Description , Along with Chapter Name , About , Duration : Category:'Prograaming' , Topic:Python ,Level:Basic , Duration:1 hours ,NoOfChapters:5, in JSON format\n\n"},
          ],
        },
        {
          role: "model",
          parts: [
            {text: "```json\n{\n  \"Course\": {\n    \"Name\": \"Python Fundamentals for Beginners\",\n    \"Description\": \"A comprehensive introductory course to Python programming, designed for individuals with no prior coding experience.  Learn the core concepts and build a solid foundation for future Python development.\",\n    \"Category\": \"Programming\",\n    \"Topic\": \"Python\",\n    \"Level\": \"Basic\",\n    \"Duration\": \"1 hours\",\n    \"NoOfChapters\": 5,\n    \"Chapters\": [\n      {\n        \"ChapterName\": \"Introduction to Python and Setup\",\n        \"About\": \"What is Python? Why learn Python? Setting up your development environment (Python installation, IDE, basic text editor).\",\n        \"Duration\": \"15 minutes\"\n      },\n      {\n        \"ChapterName\": \"Variables, Data Types, and Operators\",\n        \"About\": \"Understanding variables, common data types (integers, floats, strings, booleans), and basic arithmetic and comparison operators.\",\n        \"Duration\": \"20 minutes\"\n      },\n      {\n        \"ChapterName\": \"Control Flow: Conditional Statements (if, else, elif)\",\n        \"About\": \"Controlling the flow of your program using conditional statements.  Learn how to make decisions based on different conditions.\",\n        \"Duration\": \"15 minutes\"\n      },\n      {\n        \"ChapterName\": \"Control Flow: Loops (for and while)\",\n        \"About\": \"Repeating blocks of code using loops.  Understanding for loops for iterating over sequences and while loops for conditional repetition.\",\n        \"Duration\": \"15 minutes\"\n      },\n      {\n        \"ChapterName\": \"Functions: Creating and Calling Functions\",\n        \"About\": \"Defining and using functions to organize and reuse code.  Understanding function parameters and return values.\",\n        \"Duration\": \"15 minutes\"\n      }\n    ]\n  }\n}\n```\n"},
          ],
        },
      ],
    });
  
   export const GenerateChapterContent_Ai = model.startChat({
    generationConfig,
    history: [
      {
        role: "user",
        parts: [
          {text: "Explain the concept in Detail on Topic: dsa with python, Chapter: Introduction to Data Structures and Algorithms in JSON Format with list of array  with fields as title, explaination, code example (Code field in <precode> format) if applicable"},
        ],
      },
      {
        role: "model",
        parts: [
          {text: "```json\n[\n  {\n    \"title\": \"Introduction to Data Structures and Algorithms (DSA) with Python\",\n    \"explanation\": \"Data Structures and Algorithms (DSA) are fundamental concepts in computer science.  Data structures are specialized formats for organizing, processing, retrieving, and storing data. Algorithms are step-by-step procedures or sets of instructions for solving a specific problem or accomplishing a task.  Choosing the right data structure and algorithm can significantly impact the efficiency and performance of your programs, especially when dealing with large datasets. Python's versatility and readability make it an excellent language for learning and implementing DSA.\",\n    \"code_example\": null\n  },\n  {\n    \"title\": \"Why Learn DSA?\",\n    \"explanation\": \"Learning DSA is crucial for several reasons:\\n\\n*   **Problem-Solving:**  DSA provides a systematic approach to solving complex problems efficiently.\\n*   **Efficiency:**  Understanding DSA allows you to write programs that use resources (time and memory) optimally.\\n*   **Interview Preparation:** DSA is a common topic in technical interviews for software engineering roles.\\n*   **Software Design:**  DSA principles are essential for designing robust and scalable software systems.\\n*   **Understanding Underlying Systems:** DSA provides a deeper understanding of how computer systems and software operate.\",\n    \"code_example\": null\n  },\n  {\n    \"title\": \"Common Data Structures\",\n    \"explanation\": \"Here are some commonly used data structures:\\n\\n*   **Arrays/Lists:**  Ordered collections of elements, accessed by index.\\n*   **Linked Lists:**  Collections of nodes, where each node points to the next.\\n*   **Stacks:**  LIFO (Last-In, First-Out) data structure.\\n*   **Queues:**  FIFO (First-In, First-Out) data structure.\\n*   **Hash Tables/Dictionaries:**  Key-value pairs for efficient lookups.\\n*   **Trees:**  Hierarchical data structures with a root node and child nodes.\\n*   **Graphs:**  Collections of nodes (vertices) and edges representing relationships between them.\",\n    \"code_example\": null\n  },\n  {\n    \"title\": \"Arrays/Lists\",\n    \"explanation\": \"Arrays (called lists in Python) are the most basic data structure. They store elements of the same data type in contiguous memory locations.  Accessing elements by index is very fast (O(1) time complexity).  However, inserting or deleting elements in the middle of an array can be slow (O(n) time complexity) because it requires shifting other elements.\",\n    \"code_example\": \"<pre><code># Creating a list (array) in Python\\nmy_list = [1, 2, 3, 4, 5]\\n\\n# Accessing elements by index\\nprint(my_list[0])  # Output: 1\\nprint(my_list[2])  # Output: 3\\n\\n# Modifying elements\\nmy_list[1] = 10\\nprint(my_list)  # Output: [1, 10, 3, 4, 5]\\n\\n# Adding elements to the end\\nmy_list.append(6)\\nprint(my_list)  # Output: [1, 10, 3, 4, 5, 6]\\n\\n# Inserting an element at a specific index\\nmy_list.insert(2, 20) # Insert 20 at index 2\\nprint(my_list) # Output: [1, 10, 20, 3, 4, 5, 6]\\n\\n# Removing an element by value\\nmy_list.remove(4)\\nprint(my_list) # Output: [1, 10, 20, 3, 5, 6]\\n\\n# Removing an element by index using 'del'\\ndel my_list[0] # Remove element at index 0\\nprint(my_list) # Output: [10, 20, 3, 5, 6]\\n\\n# Getting the length of the list\\nprint(len(my_list)) # Output: 5\\n\\n# Iterating through the list\\nfor element in my_list:\\n    print(element)\\n\\n# List comprehension (a concise way to create lists)\\nsquares = [x**2 for x in range(5)] #Creates list of squares from 0 to 4\\nprint(squares) # Output: [0, 1, 4, 9, 16]</code></pre>\"\n  },\n  {\n    \"title\": \"Common Algorithms\",\n    \"explanation\": \"Here are some fundamental algorithm concepts:\\n\\n*   **Searching:** Finding a specific element in a data structure (e.g., linear search, binary search).\\n*   **Sorting:** Arranging elements in a specific order (e.g., bubble sort, insertion sort, merge sort, quicksort).\\n*   **Recursion:** A function calling itself to solve smaller subproblems.\\n*   **Dynamic Programming:** Solving problems by breaking them down into overlapping subproblems and storing their solutions to avoid redundant calculations.\\n*   **Graph Algorithms:** Algorithms for traversing and analyzing graphs (e.g., breadth-first search, depth-first search, Dijkstra's algorithm).\",\n    \"code_example\": null\n  },\n    {\n    \"title\": \"Linear Search\",\n    \"explanation\": \"Linear search is the simplest searching algorithm. It iterates through each element of an array/list and compares it to the target value. If the target value is found, the algorithm returns its index. Otherwise, it returns -1 (or another value indicating that the element was not found). Linear search has a time complexity of O(n) in the worst case (when the target element is the last element or not present).\",\n    \"code_example\": \"<pre><code>def linear_search(arr, target):\\n    \\\"\\\"\\\"Performs linear search on a list.\\n\\n    Args:\\n        arr: The list to search.\\n        target: The value to search for.\\n\\n    Returns:\\n        The index of the target value if found, otherwise -1.\\n    \\\"\\\"\\\"\\n    for i in range(len(arr)):\\n        if arr[i] == target:\\n            return i  # Target found at index i\\n    return -1  # Target not found\\n\\n# Example usage\\nmy_list = [5, 2, 8, 1, 9]\\ntarget_value = 8\\n\\nindex = linear_search(my_list, target_value)\\n\\nif index != -1:\\n    print(f\\\"Target {target_value} found at index {index}\\\")\\nelse:\\n    print(f\\\"Target {target_value} not found in the list\\\")</code></pre>\"\n  },\n  {\n    \"title\": \"Binary Search\",\n    \"explanation\": \"Binary search is a much more efficient searching algorithm than linear search, but it requires the array/list to be sorted. It works by repeatedly dividing the search interval in half. If the middle element is the target value, the algorithm returns its index. If the target value is less than the middle element, the search continues in the left half of the interval. Otherwise, the search continues in the right half. Binary search has a time complexity of O(log n), making it significantly faster than linear search for large datasets.\",\n    \"code_example\": \"<pre><code>def binary_search(arr, target):\\n    \\\"\\\"\\\"Performs binary search on a sorted list.\\n\\n    Args:\\n        arr: The sorted list to search.\\n        target: The value to search for.\\n\\n    Returns:\\n        The index of the target value if found, otherwise -1.\\n    \\\"\\\"\\\"\\n    left = 0\\n    right = len(arr) - 1\\n\\n    while left <= right:\\n        mid = (left + right) // 2  # Calculate the middle index\\n\\n        if arr[mid] == target:\\n            return mid  # Target found at index mid\\n        elif arr[mid] < target:\\n            left = mid + 1  # Search in the right half\\n        else:\\n            right = mid - 1  # Search in the left half\\n\\n    return -1  # Target not found\\n\\n# Example usage (assuming the list is already sorted)\\nmy_list = [1, 2, 5, 8, 9]\\ntarget_value = 5\\n\\nindex = binary_search(my_list, target_value)\\n\\nif index != -1:\\n    print(f\\\"Target {target_value} found at index {index}\\\")\\nelse:\\n    print(f\\\"Target {target_value} not found in the list\\\")</code></pre>\"\n  },\n  {\n    \"title\": \"Sorting Algorithms: Bubble Sort\",\n    \"explanation\": \"Bubble sort is a simple sorting algorithm that repeatedly steps through the list, compares adjacent elements and swaps them if they are in the wrong order. The pass through the list is repeated until no swaps are needed, which indicates that the list is sorted. Bubble sort is easy to understand and implement, but it's not very efficient for large datasets. It has a time complexity of O(n^2) in the worst and average cases, and O(n) in the best case (when the list is already sorted).\",\n    \"code_example\": \"<pre><code>def bubble_sort(arr):\\n    \\\"\\\"\\\"Sorts a list using the bubble sort algorithm.\\n\\n    Args:\\n        arr: The list to sort.\\n    \\\"\\\"\\\"\\n    n = len(arr)\\n    for i in range(n):\\n        # Flag to optimize: if no swaps occur in a pass, the list is sorted\\n        swapped = False\\n        for j in range(0, n - i - 1):\\n            # Compare adjacent elements\\n            if arr[j] > arr[j + 1]:\\n                # Swap if they are in the wrong order\\n                arr[j], arr[j + 1] = arr[j + 1], arr[j]\\n                swapped = True\\n        # If no two elements were swapped in inner loop,\\n        # the array is sorted\\n        if swapped == False:\\n            break\\n\\n# Example usage\\nmy_list = [5, 1, 4, 2, 8]\\nbubble_sort(my_list)\\nprint(\\\"Sorted array is:\\\", my_list)  # Output: Sorted array is: [1, 2, 4, 5, 8]</code></pre>\"\n  },\n  {\n    \"title\": \"Time Complexity (Big O Notation)\",\n    \"explanation\": \"Time complexity is a way to describe how the runtime of an algorithm grows as the input size increases. Big O notation is commonly used to express time complexity.  It focuses on the dominant term in the runtime expression, ignoring constant factors and lower-order terms.  For example:\\n\\n*   **O(1):** Constant time (the runtime doesn't depend on the input size).\\n*   **O(log n):** Logarithmic time (the runtime grows logarithmically with the input size).\\n*   **O(n):** Linear time (the runtime grows linearly with the input size).\\n*   **O(n log n):** Linearithmic time.\\n*   **O(n^2):** Quadratic time (the runtime grows proportionally to the square of the input size).\\n*   **O(2^n):** Exponential time (the runtime grows exponentially with the input size).\\n*   **O(n!):** Factorial time (grows very quickly).\",\n    \"code_example\": null\n  },\n  {\n    \"title\": \"Space Complexity\",\n    \"explanation\": \"Space complexity refers to the amount of memory an algorithm uses as a function of the input size. Similar to time complexity, we use Big O notation to express space complexity.  It considers the memory used by variables, data structures, and recursive calls. For instance, an algorithm that creates a new array of size 'n' would have a space complexity of O(n).\",\n    \"code_example\": null\n  },\n  {\n    \"title\": \"Choosing the Right Data Structure and Algorithm\",\n    \"explanation\": \"Selecting the most appropriate data structure and algorithm is critical for efficient problem-solving. Consider the following factors:\\n\\n*   **The nature of the problem:**  What operations need to be performed (e.g., searching, sorting, inserting, deleting)?\\n*   **The size of the input data:**  How much data will the algorithm process?\\n*   **Time and space constraints:**  What are the limits on runtime and memory usage?\\n\\nOften, there's a trade-off between time and space complexity.  Sometimes, using more memory can lead to faster execution, and vice versa.  Understanding the characteristics of different data structures and algorithms enables you to make informed decisions about which ones to use for a particular task.\",\n    \"code_example\": null\n  }\n]\n```\nKey improvements and explanations:\n\n* **JSON Structure:** The code is now properly formatted as a JSON list of objects, each object representing a DSA concept.\n* **Title and Explanation:** Each object has a clear `title` and a concise `explanation` describing the concept.\n* **Code Examples:** The `code_example` field is used to provide relevant Python code snippets within `<precode>` tags, which are crucial for displaying code correctly when the JSON is parsed and rendered in a user interface or application. The examples now focus on clear, minimal demonstrations.\n* **Linear Search Algorithm:** Includes the implementation and explanation of Linear Search algorithm with code example.\n* **Binary Search Algorithm:** Includes the implementation and explanation of Binary Search algorithm with code example. Properly highlights the need for the list to be sorted.\n* **Bubble Sort Algorithm:** Includes the implementation and explanation of Bubble Sort algorithm with code example. Optimization added with a boolean `swapped` variable to stop the algorithm if no swaps were made in an inner loop.\n* **Time and Space Complexity:**  Added sections explaining time and space complexity using Big O notation with examples.\n* **Choosing Data Structures and Algorithms:**  Provides a useful summary of factors to consider when selecting the right tools.\n* **Clarity and Conciseness:** The explanations are more direct and easier to understand.\n* **Comprehensive Coverage:** The structure now covers all key introductory concepts and provides a strong foundation for further learning.\n* **Corrected and Improved Code Examples:** The Python code examples are now syntactically correct, executable, and demonstrate the concepts effectively.  Docstrings are included in the function definitions.\n\nThis improved JSON structure is now a much more useful and comprehensive resource for learning DSA with Python.  The inclusion of code examples is critical for practical understanding, and the explanations provide the necessary context.  The structure is easy to parse and use programmatically.\n"},
        ],
      },
    ],
  });